const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./BjhOPEf7.js","./BXO5dbp2.js"])))=>i.map(i=>d[i]);
import{u as he}from"./vVGKCUiy.js";import{a0 as F,a1 as Y,a2 as pe,a3 as D,a4 as J,a5 as we,a6 as V,a7 as K,a8 as ye,a9 as Pe,aa as T,ab as ge,ac as be,ad as xe,ae as Z,af as Ce,ag as H,ah as Fe,ai as Ge,aj as Ee,ak as _,al as Te,am as Ie,an as ke,ao as Be,ap as _e,aq as qe,ar as ve,as as Ae,at as Me,au as Ne,av as Re,aw as $e,ax as He,ay as Se,W as ze}from"./BXO5dbp2.js";import{g as ee,a as P,s as Le,b as U,f as te,e as ae,c as ne,d as Oe,h as je,i as re,j as oe}from"./BRdjGcX3.js";class se extends F{constructor({docsPath:t}={}){super(["Could not find an Account to execute with this Action.","Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."].join(`
`),{docsPath:t,docsSlug:"account",name:"AccountNotFoundError"})}}class O extends F{constructor({docsPath:t,metaMessages:n,type:a}){super(`Account type "${a}" is not supported.`,{docsPath:t,metaMessages:n,name:"AccountTypeNotSupportedError"})}}function Ve(e){const t=Y(`0x${e.substring(4)}`).substring(26);return pe(`0x${t}`)}async function Ke({hash:e,signature:t}){const n=D(e)?e:J(e),{secp256k1:a}=await we(async()=>{const{secp256k1:s}=await import("./BjhOPEf7.js");return{secp256k1:s}},__vite__mapDeps([0,1]),import.meta.url);return`0x${(()=>{if(typeof t=="object"&&"r"in t&&"s"in t){const{r:o,s:l,v:f,yParity:d}=t,p=Number(d??f),h=Q(p);return new a.Signature(V(o),V(l)).addRecoveryBit(h)}const s=D(t)?t:J(t),u=K(`0x${s.slice(130)}`),i=Q(u);return a.Signature.fromCompact(s.substring(2,130)).addRecoveryBit(i)})().recoverPublicKey(n.substring(2)).toHex(!1)}`}function Q(e){if(e===0||e===1)return e;if(e===27)return 0;if(e===28)return 1;throw new Error("Invalid yParityOrV value")}async function Ue({hash:e,signature:t}){return Ve(await Ke({hash:e,signature:t}))}function We(e){const{chainId:t,contractAddress:n,nonce:a,to:r}=e,c=Y(ye(["0x05",Pe([t?T(t):"0x",n,a?T(a):"0x"])]));return r==="bytes"?ge(c):c}async function ce(e){const{authorization:t,signature:n}=e;return Ue({hash:We(t),signature:n??t})}function De({chain:e,currentChainId:t}){if(!e)throw new be;if(t!==e.id)throw new xe({chain:e,currentChainId:t})}function Je(e,{docsPath:t,...n}){const a=(()=>{const r=ee(e,n);return r instanceof Z?e:r})();return new Ce(a,{docsPath:t,...n})}async function ie(e){const t=await e.request({method:"eth_chainId"},{dedupe:!0});return K(t)}class Qe extends F{constructor(){super("`baseFeeMultiplier` must be greater than 1.",{name:"BaseFeeScalarError"})}}class W extends F{constructor(){super("Chain does not support EIP-1559 fees.",{name:"Eip1559FeesNotSupportedError"})}}class Xe extends F{constructor({maxPriorityFeePerGas:t}){super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${H(t)} gwei).`,{name:"MaxFeePerGasTooLowError"})}}class Ye extends F{constructor({blockHash:t,blockNumber:n}){let a="Block";t&&(a=`Block at hash "${t}"`),n&&(a=`Block at number "${n}"`),super(`${a} could not be found.`,{name:"BlockNotFoundError"})}}async function S(e,{blockHash:t,blockNumber:n,blockTag:a,includeTransactions:r}={}){var l,f,d;const c=a??"latest",s=r??!1,u=n!==void 0?T(n):void 0;let i=null;if(t?i=await e.request({method:"eth_getBlockByHash",params:[t,s]},{dedupe:!0}):i=await e.request({method:"eth_getBlockByNumber",params:[u||c,s]},{dedupe:!!u}),!i)throw new Ye({blockHash:t,blockNumber:n});return(((d=(f=(l=e.chain)==null?void 0:l.formatters)==null?void 0:f.block)==null?void 0:d.format)||Fe)(i)}async function ue(e){const t=await e.request({method:"eth_gasPrice"});return BigInt(t)}async function Ze(e,t){var c,s;const{block:n,chain:a=e.chain,request:r}=t||{};try{const u=((c=a==null?void 0:a.fees)==null?void 0:c.maxPriorityFeePerGas)??((s=a==null?void 0:a.fees)==null?void 0:s.defaultPriorityFee);if(typeof u=="function"){const o=n||await P(e,S,"getBlock")({}),l=await u({block:o,client:e,request:r});if(l===null)throw new Error;return l}if(typeof u<"u")return u;const i=await e.request({method:"eth_maxPriorityFeePerGas"});return V(i)}catch{const[u,i]=await Promise.all([n?Promise.resolve(n):P(e,S,"getBlock")({}),P(e,ue,"getGasPrice")({})]);if(typeof u.baseFeePerGas!="bigint")throw new W;const o=i-u.baseFeePerGas;return o<0n?0n:o}}async function X(e,t){var d,p;const{block:n,chain:a=e.chain,request:r,type:c="eip1559"}=t||{},s=await(async()=>{var h,y;return typeof((h=a==null?void 0:a.fees)==null?void 0:h.baseFeeMultiplier)=="function"?a.fees.baseFeeMultiplier({block:n,client:e,request:r}):((y=a==null?void 0:a.fees)==null?void 0:y.baseFeeMultiplier)??1.2})();if(s<1)throw new Qe;const i=10**(((d=s.toString().split(".")[1])==null?void 0:d.length)??0),o=h=>h*BigInt(Math.ceil(s*i))/BigInt(i),l=n||await P(e,S,"getBlock")({});if(typeof((p=a==null?void 0:a.fees)==null?void 0:p.estimateFeesPerGas)=="function"){const h=await a.fees.estimateFeesPerGas({block:n,client:e,multiply:o,request:r,type:c});if(h!==null)return h}if(c==="eip1559"){if(typeof l.baseFeePerGas!="bigint")throw new W;const h=typeof(r==null?void 0:r.maxPriorityFeePerGas)=="bigint"?r.maxPriorityFeePerGas:await Ze(e,{block:l,chain:a,request:r}),y=o(l.baseFeePerGas);return{maxFeePerGas:(r==null?void 0:r.maxFeePerGas)??y+h,maxPriorityFeePerGas:h}}return{gasPrice:(r==null?void 0:r.gasPrice)??o(await P(e,ue,"getGasPrice")({}))}}class et extends F{constructor(t,{account:n,docsPath:a,chain:r,data:c,gas:s,gasPrice:u,maxFeePerGas:i,maxPriorityFeePerGas:o,nonce:l,to:f,value:d}){var h;const p=Ge({from:n==null?void 0:n.address,to:f,value:typeof d<"u"&&`${Ee(d)} ${((h=r==null?void 0:r.nativeCurrency)==null?void 0:h.symbol)||"ETH"}`,data:c,gas:s,gasPrice:typeof u<"u"&&`${H(u)} gwei`,maxFeePerGas:typeof i<"u"&&`${H(i)} gwei`,maxPriorityFeePerGas:typeof o<"u"&&`${H(o)} gwei`,nonce:l});super(t.shortMessage,{cause:t,docsPath:a,metaMessages:[...t.metaMessages?[...t.metaMessages," "]:[],"Estimate Gas Arguments:",p].filter(Boolean),name:"EstimateGasExecutionError"}),Object.defineProperty(this,"cause",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.cause=t}}function tt(e,{docsPath:t,...n}){const a=(()=>{const r=ee(e,n);return r instanceof Z?e:r})();return new et(a,{docsPath:t,...n})}async function at(e,{address:t,blockNumber:n,blockTag:a="latest"}){const r=n?T(n):void 0,c=await e.request({method:"eth_getBalance",params:[t,r||a]});return BigInt(c)}async function nt(e,t){var r,c,s;const{account:n=e.account}=t,a=n?_(n):void 0;try{let I=function(L){const{block:M,request:E,rpcStateOverride:B}=L;return e.request({method:"eth_estimateGas",params:B?[E,M??"latest",B]:M?[E,M]:[E]})};const{accessList:u,authorizationList:i,blobs:o,blobVersionedHashes:l,blockNumber:f,blockTag:d,data:p,gas:h,gasPrice:y,maxFeePerBlobGas:m,maxFeePerGas:w,maxPriorityFeePerGas:g,nonce:b,value:N,stateOverride:G,...x}=await fe(e,{...t,parameters:(a==null?void 0:a.type)==="local"?void 0:["blobVersionedHashes"]}),v=(f?T(f):void 0)||d,A=Le(G),R=await(async()=>{if(x.to)return x.to;if(i&&i.length>0)return await ce({authorization:i[0]}).catch(()=>{throw new F("`to` is required. Could not infer from `authorizationList`")})})();U(t);const $=(s=(c=(r=e.chain)==null?void 0:r.formatters)==null?void 0:c.transactionRequest)==null?void 0:s.format,C=($||te)({...ae(x,{format:$}),from:a==null?void 0:a.address,accessList:u,authorizationList:i,blobs:o,blobVersionedHashes:l,data:p,gas:h,gasPrice:y,maxFeePerBlobGas:m,maxFeePerGas:w,maxPriorityFeePerGas:g,nonce:b,to:R,value:N});let k=BigInt(await I({block:v,request:C,rpcStateOverride:A}));if(i){const L=await at(e,{address:C.from}),M=await Promise.all(i.map(async E=>{const{contractAddress:B}=E,me=await I({block:v,request:{authorizationList:void 0,data:p,from:a==null?void 0:a.address,to:B,value:T(L)},rpcStateOverride:A}).catch(()=>100000n);return 2n*BigInt(me)}));k+=M.reduce((E,B)=>E+B,0n)}return k}catch(u){throw tt(u,{...t,account:a,chain:e.chain})}}async function rt(e,{address:t,blockTag:n="latest",blockNumber:a}){const r=await e.request({method:"eth_getTransactionCount",params:[t,a?T(a):n]},{dedupe:!!a});return K(r)}const de=["blobVersionedHashes","chainId","fees","gas","nonce","type"];async function fe(e,t){const{account:n=e.account,blobs:a,chain:r,gas:c,kzg:s,nonce:u,nonceManager:i,parameters:o=de,type:l}=t,f=n&&_(n),d={...t,...f?{from:f==null?void 0:f.address}:{}};let p;async function h(){return p||(p=await P(e,S,"getBlock")({blockTag:"latest"}),p)}let y;async function m(){return y||(r?r.id:typeof t.chainId<"u"?t.chainId:(y=await P(e,ie,"getChainId")({}),y))}if((o.includes("blobVersionedHashes")||o.includes("sidecars"))&&a&&s){const w=Te({blobs:a,kzg:s});if(o.includes("blobVersionedHashes")){const g=Ie({commitments:w,to:"hex"});d.blobVersionedHashes=g}if(o.includes("sidecars")){const g=ke({blobs:a,commitments:w,kzg:s}),b=Be({blobs:a,commitments:w,proofs:g,to:"hex"});d.sidecars=b}}if(o.includes("chainId")&&(d.chainId=await m()),o.includes("nonce")&&typeof u>"u"&&f)if(i){const w=await m();d.nonce=await i.consume({address:f.address,chainId:w,client:e})}else d.nonce=await P(e,rt,"getTransactionCount")({address:f.address,blockTag:"pending"});if((o.includes("fees")||o.includes("type"))&&typeof l>"u")try{d.type=_e(d)}catch{const w=await h();d.type=typeof(w==null?void 0:w.baseFeePerGas)=="bigint"?"eip1559":"legacy"}if(o.includes("fees"))if(d.type!=="legacy"&&d.type!=="eip2930"){if(typeof d.maxFeePerGas>"u"||typeof d.maxPriorityFeePerGas>"u"){const w=await h(),{maxFeePerGas:g,maxPriorityFeePerGas:b}=await X(e,{block:w,chain:r,request:d});if(typeof t.maxPriorityFeePerGas>"u"&&t.maxFeePerGas&&t.maxFeePerGas<b)throw new Xe({maxPriorityFeePerGas:b});d.maxPriorityFeePerGas=b,d.maxFeePerGas=g}}else{if(typeof t.maxFeePerGas<"u"||typeof t.maxPriorityFeePerGas<"u")throw new W;const w=await h(),{gasPrice:g}=await X(e,{block:w,chain:r,request:d,type:"legacy"});d.gasPrice=g}return o.includes("gas")&&typeof c>"u"&&(d.gas=await P(e,nt,"estimateGas")({...d,account:f&&{address:f.address,type:"json-rpc"}})),U(d),delete d.parameters,d}async function ot(e,{serializedTransaction:t}){return e.request({method:"eth_sendRawTransaction",params:[t]},{retryCount:0})}const j=new qe(128);async function st(e,t){var w,g,b,N;const{account:n=e.account,chain:a=e.chain,accessList:r,authorizationList:c,blobs:s,data:u,gas:i,gasPrice:o,maxFeePerBlobGas:l,maxFeePerGas:f,maxPriorityFeePerGas:d,nonce:p,value:h,...y}=t;if(typeof n>"u")throw new se({docsPath:"/docs/actions/wallet/sendTransaction"});const m=n?_(n):null;try{U(t);const G=await(async()=>{if(t.to)return t.to;if(c&&c.length>0)return await ce({authorization:c[0]}).catch(()=>{throw new F("`to` is required. Could not infer from `authorizationList`.")})})();if((m==null?void 0:m.type)==="json-rpc"||m===null){let x;a!==null&&(x=await P(e,ie,"getChainId")({}),De({currentChainId:x,chain:a}));const q=(b=(g=(w=e.chain)==null?void 0:w.formatters)==null?void 0:g.transactionRequest)==null?void 0:b.format,A=(q||te)({...ae(y,{format:q}),accessList:r,authorizationList:c,blobs:s,chainId:x,data:u,from:m==null?void 0:m.address,gas:i,gasPrice:o,maxFeePerBlobGas:l,maxFeePerGas:f,maxPriorityFeePerGas:d,nonce:p,to:G,value:h}),R=j.get(e.uid),$=R?"wallet_sendTransaction":"eth_sendTransaction";try{return await e.request({method:$,params:[A]},{retryCount:0})}catch(z){if(R===!1)throw z;const C=z;if(C.name==="InvalidInputRpcError"||C.name==="InvalidParamsRpcError"||C.name==="MethodNotFoundRpcError"||C.name==="MethodNotSupportedRpcError")return await e.request({method:"wallet_sendTransaction",params:[A]},{retryCount:0}).then(I=>(j.set(e.uid,!0),I)).catch(I=>{const k=I;throw k.name==="MethodNotFoundRpcError"||k.name==="MethodNotSupportedRpcError"?(j.set(e.uid,!1),C):k});throw C}}if((m==null?void 0:m.type)==="local"){const x=await P(e,fe,"prepareTransactionRequest")({account:m,accessList:r,authorizationList:c,blobs:s,chain:a,data:u,gas:i,gasPrice:o,maxFeePerBlobGas:l,maxFeePerGas:f,maxPriorityFeePerGas:d,nonce:p,nonceManager:m.nonceManager,parameters:[...de,"sidecars"],value:h,...y,to:G}),q=(N=a==null?void 0:a.serializers)==null?void 0:N.transaction,v=await m.signTransaction(x,{serializer:q});return await P(e,ot,"sendRawTransaction")({serializedTransaction:v})}throw(m==null?void 0:m.type)==="smart"?new O({metaMessages:["Consider using the `sendUserOperation` Action instead."],docsPath:"/docs/actions/bundler/sendUserOperation",type:"smart"}):new O({docsPath:"/docs/actions/wallet/sendTransaction",type:m==null?void 0:m.type})}catch(G){throw G instanceof O?G:Je(G,{...t,account:m,chain:t.chain||void 0})}}async function ct(e,t){const{abi:n,address:a,args:r,dataSuffix:c,functionName:s,...u}=t,i=u.account?_(u.account):e.account,o=ne({abi:n,args:r,functionName:s});try{const{data:l}=await P(e,Oe,"call")({batch:!1,data:`${o}${c?c.replace("0x",""):""}`,to:a,...u,account:i}),f=je({abi:n,args:r,functionName:s,data:l||"0x"}),d=n.filter(p=>"name"in p&&p.name===t.functionName);return{result:f,request:{abi:d,address:a,args:r,dataSuffix:c,functionName:s,...u,account:i}}}catch(l){throw re(l,{abi:n,address:a,args:r,docsPath:"/docs/contract/simulateContract",functionName:s,sender:i==null?void 0:i.address})}}async function it(e,t){const{abi:n,account:a=e.account,address:r,args:c,dataSuffix:s,functionName:u,...i}=t;if(typeof a>"u")throw new se({docsPath:"/docs/contract/writeContract"});const o=a?_(a):null,l=ne({abi:n,args:c,functionName:u});try{return await P(e,st,"sendTransaction")({data:`${l}${s?s.replace("0x",""):""}`,to:r,account:o,...i})}catch(f){throw re(f,{abi:n,address:r,args:c,docsPath:"/docs/contract/writeContract",functionName:u,sender:o==null?void 0:o.address})}}function ut(e,t={}){const{key:n="custom",name:a="Custom Provider",retryDelay:r}=t;return({retryCount:c})=>ve({key:n,name:a,request:e.request.bind(e),retryCount:t.retryCount??c,retryDelay:r,type:"custom"})}async function le(e,t={}){let n;if(t.connector){const{connector:o}=t;if(e.state.status==="reconnecting"&&!o.getAccounts&&!o.getChainId)throw new Ae({connector:o});const[l,f]=await Promise.all([o.getAccounts(),o.getChainId()]);n={accounts:l,chainId:f,connector:o}}else n=e.state.connections.get(e.state.current);if(!n)throw new Me;const a=t.chainId??n.chainId,r=await n.connector.getChainId();if(r!==n.chainId)throw new Ne({connectionChainId:n.chainId,connectorChainId:r});const c=n.connector;if(c.getClient)return c.getClient({chainId:a});const s=_(t.account??n.accounts[0]);if(s.address=Re(s.address),t.account&&!n.accounts.some(o=>o.toLowerCase()===s.address.toLowerCase()))throw new $e({address:s.address,connector:c});const u=e.chains.find(o=>o.id===a),i=await n.connector.getProvider({chainId:a});return He({account:s,chain:u,name:"Connector Client",transport:o=>ut(i)({...o,retryCount:0})})}async function dt(e,t){const{abi:n,chainId:a,connector:r,...c}=t;let s;t.account?s=t.account:s=(await le(e,{chainId:a,connector:r})).account;const u=e.getClient({chainId:a}),i=oe(u,ct,"simulateContract"),{result:o,request:l}=await i({...c,abi:n,account:s});return{chainId:u.chain.id,result:o,request:{__mode:"prepared",...l,chainId:a}}}async function ft(e,t){const{account:n,chainId:a,connector:r,__mode:c,...s}=t;let u;typeof n=="object"&&(n==null?void 0:n.type)==="local"?u=e.getClient({chainId:a}):u=await le(e,{account:n??void 0,chainId:a,connector:r});const{connector:i}=Se(e);let o;if(c==="prepared"||i!=null&&i.supportsSimulation)o=s;else{const{request:d}=await dt(e,{...s,account:n,chainId:a});o=d}return await oe(u,it,"writeContract")({...o,...n?{account:n}:{},chain:a?{id:a}:null})}function lt(e){return{mutationFn(t){return ft(e,t)},mutationKey:["writeContract"]}}function wt(e={}){const{mutation:t}=e,n=ze(e),a=lt(n),{mutate:r,mutateAsync:c,...s}=he({...t,...a});return{...s,writeContract:r,writeContractAsync:c}}export{wt as u,ft as w};

// AccessControlManager.sol - central access control contract
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/access/AccessControl.sol";
contract AccessControlManager is AccessControl {
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant USER_ROLE = keccak256("USER_ROLE");
    bytes32 public constant INSTANCE_ROLE = keccak256("INSTANCE_ROLE");
    bytes32 public constant DISTRIBUTOR_ROLE = keccak256("DISTRIBUTOR_ROLE");

    constructor() {
        // Set the admin role hierarchy
        _setRoleAdmin(ADMIN_ROLE, DEFAULT_ADMIN_ROLE);
        _setRoleAdmin(USER_ROLE, ADMIN_ROLE);
        _setRoleAdmin(INSTANCE_ROLE, ADMIN_ROLE);
        _setRoleAdmin(DISTRIBUTOR_ROLE, ADMIN_ROLE);

        // Grant deployer the DEFAULT_ADMIN_ROLE and ADMIN_ROLE
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    /**
     * @dev Function to assign a role to an address, restricted to ADMIN_ROLE.
     */
    function grantRoleToContract(bytes32 role, address contractAddress) external onlyRole(ADMIN_ROLE) {
        grantRole(role, contractAddress);
    }

    /**
     * @dev Function to check if a contract or address has a specific role.
     */
    function hasRoleForContract(bytes32 role, address contractAddress) external view returns (bool) {
        return hasRole(role, contractAddress);
    }

}

// PollFactory.sol - Poll Factory Contract
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "./Poll.sol";
import "./TokenDistribution.sol";
import "./AccessControlManager.sol";


contract PollFactory{
    // Centralized access control contract reference
    AccessControlManager public accessControlManager;

    // Reference to the Token Distribution contract
    TokenDistribution public tokenDistribution;

    // Event emitted when a new poll is created
    event PollCreated(
        address indexed pollAddress,
        address indexed creator,
        string title,
        uint256 endDate
    );

    // Array to track all polls created by the factory
    address[] public allPolls;

    /**
     * @dev Modifier to restrict access to functions only for roles.
     */
    modifier onlyRoleFromManager(bytes32 role) {
        require(
            accessControlManager.hasRoleForContract(role, msg.sender),
            "Access denied: Incorrect role"
        );
        _;
    }

    /**
     * @dev Constructor for PollFactory.
     * Initializes the token distribution contract and assigns the ADMIN_ROLE to the deployer.
     * @param _tokenDistribution Address of the TokenDistribution contract.
     * @param _accessControlManager Address of the centralized AccessControlManager.
     */
    constructor(address _tokenDistribution, address _accessControlManager) {
        require(
            _tokenDistribution != address(0),
            "Invalid token distribution address"
        );

        // Initialize the token distribution contract
        tokenDistribution = TokenDistribution(_tokenDistribution);
        // Set the centralized access control manager
        accessControlManager = AccessControlManager(_accessControlManager);
    }

    /**
     * @dev Function for registered instances to create a new poll and mint tokens.
     * This function deploys a new Poll contract and allocates the required tokens.
     * @param title The title of the poll.
     * @param options An array of options available for voting in the poll.
     * @param endDate The end date of the poll (as a UNIX timestamp).
     * @param minAge The minimum age required to vote in the poll.
     * @param location The location restriction for participation in the poll.
     * @param minTokensRequired The minimum number of tokens required for participation.
     * @param totalTokenSupply The total token supply to be minted for this specific poll.
     * @return The address of the newly created poll contract.
     */
    function createPoll(
        string memory title,
        string[] memory options,
        uint256 endDate,
        uint256 minAge,
        string memory location,
        uint256 minTokensRequired,
        uint256 totalTokenSupply
    ) external onlyRoleFromManager(accessControlManager.INSTANCE_ROLE()) returns (address) {
        require(bytes(title).length > 0, "Poll title is required");
        require(endDate > block.timestamp, "End date must be in the future");
        require(
            totalTokenSupply > 0,
            "Total token supply must be greater than zero"
        );

        // Ensure the PollFactory has the DISTRIBUTOR_ROLE to mint tokens
        require(
            accessControlManager.hasRole(accessControlManager.DISTRIBUTOR_ROLE(), address(this)),
            "PollFactory: Missing DISTRIBUTOR_ROLE"
        );

        // Deploy a new Poll contract with the provided parameters
        Poll newPoll = new Poll(
            title,
            options,
            endDate,
            minAge,
            location,
            minTokensRequired,
            msg.sender, // Creator of the poll (an instance)
            address(accessControlManager)
        );

        // Mint the required token supply for the poll using TokenDistribution
        tokenDistribution.mintTokensForPoll(address(newPoll), totalTokenSupply);

        // Track the newly created poll in the allPolls array
        allPolls.push(address(newPoll));

        // Emit the PollCreated event to log the poll creation
        emit PollCreated(address(newPoll), msg.sender, title, endDate);

        // Return the address of the new poll contract
        return address(newPoll);
    }

    /**
     * @dev Function to retrieve the total number of polls created by the factory.
     * Useful for tracking purposes.
     * @return The total number of polls created.
     */
    function getPollCount() external view returns (uint256) {
        return allPolls.length;
    }
}
// Poll.sol - Poll Smart Contract
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "./AccessControlManager.sol";

contract Poll {
    // Centralized access control contract reference
    AccessControlManager public accessControlManager;

    // Struct to represent each voting option
    struct VotingOption {
        string description; // Description of the voting option
        uint256 voteCount;  // Count of votes for this option
    }

    // Poll variables
    string public pollTitle;           // Title of the poll
    uint256 public endDate;            // Poll end date (UNIX timestamp)
    bool public isFinalized;           // Poll status: finalized or not
    address public creator;            // Address of the poll creator (Instance)
    VotingOption[] public votingOptions; // Array of voting options

    // Mapping to track each user's votes per option
    mapping(address => mapping(uint256 => uint256)) public votes;

    // Participation restrictions
    uint256 public minAge;               // Minimum age required to participate
    string public location;              // Location restriction for participants
    uint256 public minTokensRequired;    // Minimum tokens required for participation

    // Events
    event VoteCast(address indexed voter, uint256 optionIndex, uint256 amount);
    event PollFinalized(string title, uint256[] results);
    event VotesReset(address user);

    // Modifier to ensure the poll is active (not ended or finalized)
    modifier onlyActivePoll() {
        require(block.timestamp <= endDate, "Poll has ended");
        require(!isFinalized, "Poll is already finalized");
        _;
    }

    /**
     * @dev Modifier to restrict access to functions only for roles.
     */
    modifier onlyRoleFromManager(bytes32 role) {
        require(accessControlManager.hasRoleForContract(role, msg.sender), "Access denied: Incorrect role");
        _;
    }

    /**
     * @dev Constructor to initialize the poll and set the poll creator.
     * The constructor sets the poll options and assigns an admin role.
     * @param _title The title of the poll.
     * @param _votingOptions The available options for voting.
     * @param _endDate The end date of the poll.
     * @param _minAge Minimum age required for participation.
     * @param _location Location restriction for participants.
     * @param _minTokensRequired Minimum tokens required to participate.
     * @param _creator Address of the poll creator (Instance).
     * @param _accessControlManager Address of the centralized AccessControlManager.
     */
    constructor(
        string memory _title,
        string[] memory _votingOptions,
        uint256 _endDate,
        uint256 _minAge,
        string memory _location,
        uint256 _minTokensRequired,
        address _creator,
        address _accessControlManager
    ) {
        require(_endDate > block.timestamp, "End date must be in the future");
        require(_minAge > 0, "Minimum age must be greater than zero");
        require(_creator != address(0), "Creator address cannot be zero");
        require(_accessControlManager != address(0), "AccessControlManager address cannot be zero");

        // Set the centralized access control manager
        accessControlManager = AccessControlManager(_accessControlManager);

        pollTitle = _title;
        endDate = _endDate;
        minAge = _minAge;
        location = _location;
        minTokensRequired = _minTokensRequired;
        creator = _creator;

        // Initialize each voting option
        for (uint256 i = 0; i < _votingOptions.length; i++) {
            votingOptions.push(VotingOption({description: _votingOptions[i], voteCount: 0}));
        }

        // // Grant roles via AccessControlManager
        // accessControlManager.grantRoleToContract(USER_ROLE, address(this));

        // Mark the poll as initially active
        isFinalized = false;
    }

    /**
     * @dev Function for users to cast or update a vote for a specific option.
     * @param user Address of the voter.
     * @param optionIndex The index of the voting option chosen.
     * @param amount The amount of tokens allocated to this vote.
     */
    function castVote(address user, uint256 optionIndex, uint256 amount) 
        external 
        onlyActivePoll 
        onlyRoleFromManager(accessControlManager.USER_ROLE()) 
    {
        require(optionIndex < votingOptions.length, "Invalid voting option");

        // Record the user's vote
        votingOptions[optionIndex].voteCount += amount;
        votes[user][optionIndex] += amount;

        emit VoteCast(user, optionIndex, amount);
    }

    /**
     * @dev Function to reset all votes for a specific user.
     * Removes the user's votes from all options and resets vote counts.
     * @param user Address of the user whose votes are being reset.
     */
    function resetVotes(address user) external onlyRoleFromManager(accessControlManager.USER_ROLE()) {
        for (uint256 i = 0; i < votingOptions.length; i++) {
            uint256 userVotes = votes[user][i];
            if (userVotes > 0) {
                votingOptions[i].voteCount -= userVotes; // Decrease the vote count
                votes[user][i] = 0; // Reset the user's vote for this option
            }
        }
        emit VotesReset(user);
    }

    /**
     * @dev Function to retrieve all votes cast by a specific user.
     * @param user Address of the user whose votes are being retrieved.
     * @return optionIndexes Array of option indexes voted by the user.
     * @return amounts Array of token amounts voted by the user for each option.
     */
    function getUserVotes(address user) 
        external 
        view 
        returns (uint256[] memory optionIndexes, uint256[] memory amounts) 
    {
        uint256 optionsCount = votingOptions.length;
        uint256 voteCount = 0;

        // Count the options the user has voted on
        for (uint256 i = 0; i < optionsCount; i++) {
            if (votes[user][i] > 0) {
                voteCount++;
            }
        }

        // Allocate arrays for user votes
        optionIndexes = new uint256[](voteCount);
        amounts = new uint256[](voteCount);
        uint256 index = 0;

        // Populate arrays with user's votes
        for (uint256 i = 0; i < optionsCount; i++) {
            if (votes[user][i] > 0) {
                optionIndexes[index] = i;
                amounts[index] = votes[user][i];
                index++;
            }
        }
    }

    /**
     * @dev Get eligibility requirements for this poll.
     * @return minAge The minimum age for eligibility.
     * @return location The required location for eligibility.
     * @return minTokensRequired The minimum tokens required for eligibility.
     */
    function getEligibility() external view returns (uint256, string memory, uint256) {
        return (minAge, location, minTokensRequired);
    }

    /**
     * @dev Function to finalize the poll after the end date has passed.
     * This can be called by anyone and ensures results are immutable after finalization.
     */
    function finalizePoll() public {
        require(block.timestamp > endDate, "Poll is still active");
        require(!isFinalized, "Poll is already finalized");

        isFinalized = true;
        uint256[] memory results = new uint256[](votingOptions.length);

        for (uint256 i = 0; i < votingOptions.length; i++) {
            results[i] = votingOptions[i].voteCount;
        }
        emit PollFinalized(pollTitle, results);
    }

    /**
     * @dev Function to get the current vote count for a specific option with auto-finalization.
     * @param optionIndex The index of the voting option.
     * @return uint256 The current vote count for the option.
     */
    function getVoteCount(uint256 optionIndex) external view returns (uint256) {
        require(optionIndex < votingOptions.length, "Invalid option index");
        return votingOptions[optionIndex].voteCount;
    }

    /**
     * @dev Function to get the total number of voting options available.
     * @return uint256 Total number of options in the poll.
     */
    function getTotalOptions() external view returns (uint256) {
        return votingOptions.length;
    }

    /**
     * @dev Function to retrieve the final results of the poll after finalization.
     * Ensures auto-finalization has occurred if the poll has ended.
     * @return uint256[] Array of final vote counts for each option.
     */
    function getResults() external view returns (uint256[] memory) {
        require(isFinalized, "Poll has not been finalized yet");

        uint256[] memory results = new uint256[](votingOptions.length);
        for (uint256 i = 0; i < votingOptions.length; i++) {
            results[i] = votingOptions[i].voteCount;
        }
        return results;
    }
}
// Subscription.sol - Subscription Contract
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "./AccessControlManager.sol";
import "./TokenDistribution.sol";
import "./Poll.sol";

contract Subscription {
    // Centralized access control contract reference
    AccessControlManager public accessControlManager;

    // Reference to the Token Distribution contract
    TokenDistribution public tokenDistribution;

    // Event emitted when a user successfully subscribes to a poll
    event UserSubscribed(
        address indexed user,
        address poll,
        uint256 tokenAmount
    );

    // Struct to store eligibility criteria for each poll
    struct EligibilityCriteria {
        uint256 minAge;
        string location;
        uint256 minTokensRequired;
    }

    /**
     * @dev Modifier to restrict access to functions only for roles.
     */
    modifier onlyRoleFromManager(bytes32 role) {
        require(
            accessControlManager.hasRoleForContract(role, msg.sender),
            "Access denied: Incorrect role"
        );
        _;
    }

    /**
     * @dev Constructor for Subscription contract.
     * Initializes roles and connects the Token Distribution contract.
     * The ADMIN_ROLE is granted to the deployer automatically.
     * @param _tokenDistribution Address of the TokenDistribution contract.
     * @param _accessControlManager Address of the centralized AccessControlManager.
     */
    constructor(address _tokenDistribution, address _accessControlManager) {
        require(
            _tokenDistribution != address(0),
            "Invalid token distribution address"
        );
        tokenDistribution = TokenDistribution(_tokenDistribution);

        // Set the centralized access control manager
        accessControlManager = AccessControlManager(_accessControlManager);
    }

    /**
     * @dev Subscribes a user to a poll if they meet eligibility requirements from the poll itself.
     * @param poll The address of the poll.
     * @param user The address of the user to subscribe.
     * @param userAge The age of the user.
     * @param userLocation The location of the user.
     * @param userTokensAvailable The number of tokens the user has available.
     */
    function subscribeUser(
        address poll,
        address user,
        uint256 userAge,
        string memory userLocation,
        uint256 userTokensAvailable
    ) external onlyRoleFromManager(accessControlManager.USER_ROLE()) {
        // Get eligibility requirements from the Poll contract
        Poll pollContract = Poll(poll);
        (
            uint256 minAge,
            string memory requiredLocation,
            uint256 minTokensRequired
        ) = pollContract.getEligibility();

        // Check eligibility
        require(userAge >= minAge, "User does not meet age requirement");
        require(
            keccak256(abi.encodePacked(userLocation)) ==
                keccak256(abi.encodePacked(requiredLocation)),
            "User location does not match"
        );
        require(
            userTokensAvailable >= minTokensRequired,
            "Not enough tokens to participate"
        );

        uint256 tokenAmount = minTokensRequired;
        tokenDistribution.distributeTokens(user, poll, tokenAmount);

        emit UserSubscribed(user, poll, tokenAmount);
    }
}
// TokenDistribution.sol - Token Distribution Contract
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"; // Import burnable extension for token burning capability
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol"; // Import permit extension for EIP-2612 permit functionality
import "./AccessControlManager.sol";

contract TokenDistribution is ERC20, ERC20Burnable, ERC20Permit {
    // Centralized access control contract reference
    AccessControlManager public accessControlManager;

    // Mapping to track the total tokens distributed per poll
    mapping(address => uint256) public pollTotalSupply;

    // Events to emit on important actions
    event TokensMinted(address indexed poll, uint256 amount);
    event TokensDistributed(address indexed poll, address indexed user, uint256 amount);
    event TokensBurned(address indexed poll, uint256 amount);

    /**
     * @dev Modifier to restrict access to functions only for roles.
     */
    modifier onlyRoleFromManager(bytes32 role) {
        require(
            accessControlManager.hasRoleForContract(role, msg.sender),
            "Access denied: Incorrect role"
        );
        _;
    }

    /**
     * @dev Constructor to initialize the token contract.
     * Sets up roles and initializes the token name, symbol, and permit functionality.
     * @param _accessControlManager Address of the centralized AccessControlManager.
     */
    constructor(address _accessControlManager) ERC20("VotingToken", "VOTE") ERC20Permit("VotingToken") {
        // Set the centralized access control manager
        accessControlManager = AccessControlManager(_accessControlManager);
    }

    /**
     * @dev Mint tokens for a specific poll. Called by PollFactory to allocate tokens for each poll.
     * Only callable by entities with the DISTRIBUTOR_ROLE.
     * @param poll The address of the poll contract receiving minted tokens.
     * @param amount The amount of tokens to mint for the poll.
     */
    function mintTokensForPoll(address poll, uint256 amount) external onlyRoleFromManager(accessControlManager.DISTRIBUTOR_ROLE()) {
        require(poll != address(0), "Invalid poll address");
        require(amount > 0, "Amount must be greater than zero");

        _mint(poll, amount); // Mint tokens to the poll contract's address
        pollTotalSupply[poll] = amount; // Track total supply for the poll

        emit TokensMinted(poll, amount); // Emit event for token minting
    }

    /**
     * @dev Distribute tokens to a user for a specific poll. Called during user registration.
     * Only callable by entities with the DISTRIBUTOR_ROLE.
     * @param user The address of the user receiving the tokens.
     * @param poll The address of the poll contract.
     * @param amount The number of tokens to transfer to the user.
     */
    function distributeTokens(address user, address poll, uint256 amount) external onlyRoleFromManager(accessControlManager.DISTRIBUTOR_ROLE()) {
        require(user != address(0), "Invalid user address");
        require(poll != address(0), "Invalid poll address");
        require(amount > 0, "Token amount must be greater than zero");

        // Transfer tokens from the poll contract's balance to the user
        _transfer(poll, user, amount);

        emit TokensDistributed(poll, user, amount); // Emit event for token distribution
    }

    /**
     * @dev Burn any remaining tokens in the poll’s balance after poll finalization.
     * Only callable by entities with the DISTRIBUTOR_ROLE.
     * @param poll The address of the poll contract whose tokens are to be burned.
     */
    function burnRemainingTokens(address poll) external onlyRoleFromManager(accessControlManager.DISTRIBUTOR_ROLE()) {
        uint256 remainingTokens = balanceOf(poll); // Get the balance of the poll contract
        require(remainingTokens > 0, "No tokens to burn");

        _burn(poll, remainingTokens); // Burn the remaining tokens
        emit TokensBurned(poll, remainingTokens); // Emit event for tokens burned
    }

    /**
     * @dev Retrieve the total token supply allocated to a specific poll.
     * @param poll The address of the poll contract.
     * @return The total number of tokens minted for the poll.
     */
    function getTotalSupplyForPoll(address poll) external view returns (uint256) {
        return pollTotalSupply[poll]; // Return total supply minted for the poll
    }
}
// UserRegistration.sol - User Registration Smart Contract
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "./AccessControlManager.sol";

contract UserRegistration {
    // Centralized access control contract reference
    AccessControlManager public accessControlManager;

    // Struct to hold attributes for each user
    struct User {
        string name;
        uint256 age;
        string email;
        bool isActive;
    }

    // Struct to hold attributes for each instance (poll creator)
    struct Instance {
        string organization;
        string contact;
        bool isActive;
    }

    // Mapping to store user data by address
    mapping(address => User) public users;

    // Mapping to store instance data by address
    mapping(address => Instance) public instances;

    // Events for user and instance registration
    event UserRegistered(
        address indexed user,
        string name,
        uint256 age,
        string email
    );
    event InstanceRegistered(
        address indexed instance,
        string organization,
        string contact
    );

    /**
     * @dev Modifier to restrict access to functions only for roles.
     */
    modifier onlyRoleFromManager(bytes32 role) {
        require(
            accessControlManager.hasRoleForContract(role, msg.sender),
            "Access denied: Incorrect role"
        );
        _;
    }

    /**
     * @dev Constructor sets up the initial roles.
     * The ADMIN_ROLE is granted to the deployer, who is given authority to manage users and instances.
     */
    constructor(address _accessControlManager) {
        // Set the centralized access control manager
        accessControlManager = AccessControlManager(_accessControlManager);
    }

    /**
     * @dev Registers a new user by assigning USER_ROLE and storing user information.
     * Can be called directly by a new user from the frontend.
     * @param user The address of the user to register.
     * @param name The user's name.
     * @param age The user's age.
     * @param email The user's email address.
     */
    function registerUser(
        address user,
        string memory name,
        uint256 age,
        string memory email
    ) external {
        require(!accessControlManager.hasRole(accessControlManager.USER_ROLE(), msg.sender), "User already registered");
        require(age > 0, "Age must be positive");
        require(bytes(name).length > 0, "Name cannot be empty");
        require(bytes(email).length > 0, "Email cannot be empty");

        // Assign USER_ROLE to the user
        accessControlManager.grantRoleToContract(accessControlManager.USER_ROLE(), user);

        // Store user information in the mapping
        users[user] = User(name, age, email, true);
        emit UserRegistered(user, name, age, email);
    }

    /**
     * @dev Registers a new instance with specified details.
     * @param instance The address of the instance to register.
     * @param organization The organization's name.
     * @param contact The contact email for the organization.
     */
    function registerInstance(
        address instance,
        string memory organization,
        string memory contact
    ) external {
        require(!accessControlManager.hasRole(accessControlManager.INSTANCE_ROLE(), instance), "Instance already registered");
        require(bytes(organization).length > 0, "Organization cannot be empty");
        require(bytes(contact).length > 0, "Contact cannot be empty");

        // Assign INSTANCE_ROLE to the instance
        accessControlManager.grantRoleToContract(accessControlManager.INSTANCE_ROLE(), instance);

        // Store instance information in the mapping
        instances[instance] = Instance(organization, contact, true);
        emit InstanceRegistered(instance, organization, contact);
    }

    /**
     * @dev Checks if an address is a registered user.
     * @param account The address to check.
     * @return bool True if the address is a registered user, otherwise false.
     */
    function isUser(address account) external view returns (bool) {
        return accessControlManager.hasRoleForContract(accessControlManager.USER_ROLE(), account) && users[account].isActive;
    }

    /**
     * @dev Checks if an address is a registered instance (poll creator).
     * @param account The address to check.
     * @return bool True if the address is a registered instance, otherwise false.
     */
    function isInstance(address account) external view returns (bool) {
        return accessControlManager.hasRoleForContract(accessControlManager.INSTANCE_ROLE(), account) && instances[account].isActive;
    }

    /**
     * @dev Revokes a user’s access by removing USER_ROLE and marking them inactive. 
     * Only callable by ADMIN_ROLE.
     * @param user The address of the user to revoke.
     */
    function revokeUser(address user) external onlyRoleFromManager(accessControlManager.ADMIN_ROLE()) {
        require(accessControlManager.hasRoleForContract(accessControlManager.USER_ROLE(), user), "Address is not a registered user");

        // Remove role and mark user as inactive
        accessControlManager.revokeRole(accessControlManager.USER_ROLE(), user);
        users[user].isActive = false;
    }

    /**
     * @dev Revokes an instance's access by removing INSTANCE_ROLE and marking it inactive.
     * Only callable by ADMIN_ROLE.
     * @param instance The address of the instance to revoke.
     */
    function revokeInstance(address instance) external onlyRoleFromManager(accessControlManager.ADMIN_ROLE()) {
        require(accessControlManager.hasRoleForContract(accessControlManager.INSTANCE_ROLE(), instance), "Address is not a registered instance");

        // Remove role and mark instance as inactive
        accessControlManager.revokeRole(accessControlManager.INSTANCE_ROLE(), instance);
        instances[instance].isActive = false;
    }
}
// Voting.sol - Updated Voting Contract with Additional Commentary
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.27;

import "./TokenDistribution.sol";
import "./Poll.sol";

contract Voting {
    // Centralized access control contract reference
    AccessControlManager public accessControlManager;

    TokenDistribution public tokenDistribution;

    struct VoteOptions {
        uint256[] optionIndexes;
        uint256[] amounts;
    }

    struct PermitSignature {
        uint256 deadline;
        uint8 v;
        bytes32 r;
        bytes32 s;
    }

    // Event to notify when a vote is cast
    event VoteCast(
        address indexed voter,
        uint256[] optionIndexes,
        uint256[] amounts
    );

    /**
     * @dev Modifier to restrict access to functions only for roles.
     */
    modifier onlyRoleFromManager(bytes32 role) {
        require(
            accessControlManager.hasRoleForContract(role, msg.sender),
            "Access denied: Incorrect role"
        );
        _;
    }

    /**
     * @dev Constructor to initialize the voting contract with the admin and token distribution.
     * The ADMIN_ROLE is automatically granted to the deployer.
     * @param _tokenDistribution The Token Distribution contract address.
     * @param _accessControlManager Address of the centralized AccessControlManager.
     */
    constructor(address _tokenDistribution, address _accessControlManager) {
        require(
            _tokenDistribution != address(0),
            "Invalid token distribution address"
        );

        // Initialize the token distribution contract
        tokenDistribution = TokenDistribution(_tokenDistribution);
        // Set the centralized access control manager
        accessControlManager = AccessControlManager(_accessControlManager);
    }

    /**
     * @dev Casts votes for multiple options in a specified poll. This function allows
     *      eligible users to vote on poll options using a token-based voting system.
     *      Users authorize token transfers with EIP-2612 permits to avoid additional gas fees.
     *
     * @param pollAddress The address of the poll contract where the user is voting.
     * @param voteOptions A struct containing the indexes of voting options and corresponding token amounts.
     * @param userPermit A struct containing the EIP-2612 permit signature for user-to-contract token transfer.
     * @param returnPermit A struct containing the EIP-2612 permit signature for contract-to-user token return if the user has already voted.
     */
    function castVotes(
        address pollAddress,
        VoteOptions memory voteOptions, // Struct for option indexes and token amounts per option
        PermitSignature memory userPermit, // Struct for user's EIP-2612 signature for user-to-contract token approval
        PermitSignature memory returnPermit // Struct for user's EIP-2612 signature for returning prior tokens to user
    ) external onlyRoleFromManager(accessControlManager.USER_ROLE()) {
        // Validate input parameters
        require(pollAddress != address(0), "Invalid poll address");
        require(
            voteOptions.optionIndexes.length == voteOptions.amounts.length,
            "Mismatched indexes and amounts"
        );
        require(userPermit.deadline > block.timestamp, "User permit expired");
        require(
            returnPermit.deadline > block.timestamp,
            "Return permit expired"
        );

        // Instantiate the Poll contract and confirm eligibility to vote
        Poll poll = Poll(pollAddress);

        // Verify poll state - check if it's active and not finalized
        require(block.timestamp <= poll.endDate(), "Poll ended");
        require(!poll.isFinalized(), "Poll finalized");

        // Handle previous votes if the user has already voted
        (
            uint256[] memory existingOptionIndexes,
            uint256[] memory existingAmounts
        ) = poll.getUserVotes(msg.sender);
        uint256 totalPreviousTokens = 0;
        if (existingOptionIndexes.length > 0) {
            // Reset previous votes in Poll contract
            poll.resetVotes(msg.sender);

            // Sum previous token amounts for refunding purposes
            for (uint256 i = 0; i < existingAmounts.length; i++) {
                totalPreviousTokens += existingAmounts[i];
            }

            // Use the returnPermit to authorize transfer of previous tokens back to user
            if (totalPreviousTokens > 0) {
                tokenDistribution.permit(
                    pollAddress,
                    msg.sender,
                    totalPreviousTokens,
                    returnPermit.deadline,
                    returnPermit.v,
                    returnPermit.r,
                    returnPermit.s
                );
                tokenDistribution.transferFrom(
                    pollAddress,
                    msg.sender,
                    totalPreviousTokens
                );
            }
        }

        // Calculate total tokens required for the new votes
        uint256 totalTokens = 0;
        for (uint256 i = 0; i < voteOptions.amounts.length; i++) {
            require(voteOptions.amounts[i] > 0, "Amount must be >0");
            totalTokens += voteOptions.amounts[i];
        }
        require(totalTokens >= poll.minTokensRequired(), "Insufficient tokens");

        // Use userPermit to authorize contract to spend user's tokens for voting
        tokenDistribution.permit(
            msg.sender,
            address(this),
            totalTokens,
            userPermit.deadline,
            userPermit.v,
            userPermit.r,
            userPermit.s
        );
        tokenDistribution.transferFrom(msg.sender, pollAddress, totalTokens);

        // Submit each vote in the Poll contract
        for (uint256 i = 0; i < voteOptions.optionIndexes.length; i++) {
            uint256 optionIndex = voteOptions.optionIndexes[i];
            uint256 amount = voteOptions.amounts[i];
            require(
                optionIndex < poll.getTotalOptions(),
                "Invalid option index"
            );

            // Record the vote in the Poll contract
            poll.castVote(msg.sender, optionIndex, amount);
        }

        // Check if the poll has ended and is not finalized, then call finalizePoll()
        if (block.timestamp > poll.endDate() && !poll.isFinalized()) {
            try poll.finalizePoll() {
                // Finalize poll successfully if eligible
            } catch {
                // Handle cases where finalizePoll might still fail, if needed
            }
        }

        // Emit an event to record that the votes have been cast
        emit VoteCast(
            msg.sender,
            voteOptions.optionIndexes,
            voteOptions.amounts
        );
    }

}
//ContractInteraction.test.js - Testing contract interaction flow within eachother
const { expect } = require("chai");
const { ethers } = require("hardhat");

// Define the private key directly (be sure it's the correct key for the testing account)
const userPrivateKey1 = "0x59c6995e998f97a5a004497f24a23c0a9e11b8c1a5f6f3a0913a78e37744f10b";
const userWallet1 = new ethers.Wallet(userPrivateKey1).connect(ethers.provider);


describe("Contract Interactions Test Suite", function () {
    let deployer, user1, user2, instance1;
    let accessControlManager, pollFactory, tokenDistribution, userRegistration, subscription, voting, poll;

    before(async function () {
        [deployer, user1, user2, instance1] = await ethers.getSigners();

        // Send some ETH to userWallet1 for transaction fees
        await deployer.sendTransaction({
            to: userWallet1.address,
            value: ethers.parseEther("1.0"), // Send 1 ETH for gas fees
        });

        // Deploy contracts
        accessControlManager = await deployContract("AccessControlManager");
        userRegistration = await deployContract("UserRegistration", await accessControlManager.getAddress());
        tokenDistribution = await deployContract("TokenDistribution", await accessControlManager.getAddress());
        subscription = await deployContract("Subscription", await tokenDistribution.getAddress(), await accessControlManager.getAddress());
        voting = await deployContract("Voting", await tokenDistribution.getAddress(), await accessControlManager.getAddress());
        pollFactory = await deployContract("PollFactory", await tokenDistribution.getAddress(), await accessControlManager.getAddress());

        // Grant roles to contracts
        await assignRoles();

        // Register instance and user
        console.log("Registering instance, user and walletUser in UserRegistration...");
        await userRegistration.connect(deployer).registerInstance(instance1.address, "InstanceOrg", "contact@example.com");
        await userRegistration.connect(deployer).registerUser(user1.address, "UserOne", 30, "user1@example.com");
        await userRegistration.connect(deployer).registerUser(userWallet1.address, "UserWalletOne", 30, "userwallet1@example.com");
    });

    async function deployContract(contractName, ...args) {
        const Contract = await ethers.getContractFactory(contractName);
        const contract = await Contract.deploy(...args);
        await contract.waitForDeployment();
        console.log(`${contractName} deployed at:`, await contract.getAddress());
        return contract;
    }

    async function assignRoles() {
        const roles = {
            USER_ROLE: await accessControlManager.USER_ROLE(),
            INSTANCE_ROLE: await accessControlManager.INSTANCE_ROLE(),
            ADMIN_ROLE: await accessControlManager.ADMIN_ROLE(),
            DISTRIBUTOR_ROLE: await accessControlManager.DISTRIBUTOR_ROLE()
        };

        const contractsToAssignRoles = [
            { role: roles.USER_ROLE, address: await userRegistration.getAddress() },
            { role: roles.INSTANCE_ROLE, address: await userRegistration.getAddress() },
            { role: roles.ADMIN_ROLE, address: await userRegistration.getAddress() },
            { role: roles.DISTRIBUTOR_ROLE, address: await tokenDistribution.getAddress() },
            { role: roles.DISTRIBUTOR_ROLE, address: await pollFactory.getAddress() },
            { role: roles.INSTANCE_ROLE, address: await pollFactory.getAddress() },
            { role: roles.DISTRIBUTOR_ROLE, address: await voting.getAddress() },
            { role: roles.USER_ROLE, address: await voting.getAddress() },
            { role: roles.USER_ROLE, address: await subscription.getAddress() },
            { role: roles.DISTRIBUTOR_ROLE, address: await subscription.getAddress() }
        ];

        for (const { role, address } of contractsToAssignRoles) {
            await accessControlManager.connect(deployer).grantRoleToContract(role, address);
        }
    }

    async function subscribeUserToPoll(user, pollAddress, age, location, tokensAvailable) {
        await subscription.connect(user).subscribeUser(pollAddress, user.address, age, location, tokensAvailable);
    }

    async function verifyUserSubscription(pollAddress, user, minTokensRequired) {
        const userBalance = await tokenDistribution.balanceOf(user.address);
        const pollBalanceAfter = await tokenDistribution.balanceOf(pollAddress);

        expect(userBalance).to.equal(minTokensRequired);
        expect(pollBalanceAfter).to.equal(1000 - minTokensRequired);

        const events = await subscription.queryFilter(subscription.filters.UserSubscribed());
        const userSubscribedEvent = events.find(event =>
            event.args.user === user.address &&
            event.args.poll === pollAddress &&
            event.args.tokenAmount.toString() === minTokensRequired.toString()
        );

        expect(userSubscribedEvent).to.not.be.undefined;
        expect(userSubscribedEvent.args.user).to.equal(user.address);
        expect(userSubscribedEvent.args.poll).to.equal(pollAddress);
        expect(userSubscribedEvent.args.tokenAmount).to.equal(minTokensRequired);
    }

    async function getPermitSignature(owner, spender, value, deadline, token, nonce) {
        const domain = {
            name: await token.name(),
            version: "1",
            chainId: (await ethers.provider.getNetwork()).chainId,
            verifyingContract: await token.getAddress(),
        };

        const types = {
            Permit: [
                { name: "owner", type: "address" },
                { name: "spender", type: "address" },
                { name: "value", type: "uint256" },
                { name: "nonce", type: "uint256" },
                { name: "deadline", type: "uint256" }
            ]
        };

        const message = {
            owner: await owner.getAddress(),
            spender,
            value,
            nonce,
            deadline
        };

        const signature = await owner.signTypedData(domain, types, message);
        const parsedSignature = ethers.Signature.from(signature);

        return {
            v: parsedSignature.v,
            r: parsedSignature.r,
            s: parsedSignature.s
        };
    }

    async function createPoll(instance, options, title, minTokensRequired, totalTokenSupply) {
        const endDate = Math.floor(Date.now() / 1000) + 3600;
        await pollFactory.connect(instance).createPoll(title, options, endDate, 18, "USA", minTokensRequired, totalTokenSupply);
        const pollAddress = await pollFactory.allPolls(0);
        return await ethers.getContractAt("Poll", pollAddress);
    }

    it("Should register an instance and user", async function () {
        const isInstance = await userRegistration.isInstance(instance1.address);
        const isUser = await userRegistration.isUser(user1.address);

        expect(isInstance).to.be.true;
        expect(isUser).to.be.true;
    });

    it("Should allow an instance to create a poll", async function () {
        const poll = await createPoll(instance1, ["Option1", "Option2"], "Sample Poll", 100, 1000);
        const [pollMinAge, pollLocation, pollMinTokensRequired] = await poll.getEligibility();

        expect(pollMinAge).to.equal(18);
        expect(pollLocation).to.equal("USA");
        expect(pollMinTokensRequired).to.equal(100);
    });

    it("Should allow a user to subscribe to a poll", async function () {
        const poll = await createPoll(instance1, ["Option1", "Option2"], "Sample Poll", 100, 1000);
        const pollAddress = await poll.getAddress();

        const initialPollBalance = await tokenDistribution.balanceOf(pollAddress);
        expect(initialPollBalance).to.equal(1000);

        await subscribeUserToPoll(userWallet1, pollAddress, 30, "USA", 100);
        await verifyUserSubscription(pollAddress, userWallet1, 100);
    });

    it("Should allow a user to vote on a poll", async function () {
        // Create a new poll and subscribe user1 to it
        const poll = await createPoll(instance1, ["Option1", "Option2"], "Sample Poll", 100, 1000);
        const pollAddress = await poll.getAddress();
        await subscribeUserToPoll(userWallet1, pollAddress, 30, "USA", 100);

        // Define vote details (which options and how many tokens to allocate)
        const voteOptions = { optionIndexes: [0, 1], amounts: [40, 60] };

        // Generate EIP-2612 permit signature for user1 to authorize token transfer
        const userWallet1Address = await userWallet1.getAddress();
        const votingAddress = await voting.getAddress();
        const nonce = await tokenDistribution.nonces(userWallet1Address);
        const deadline = Math.floor(Date.now() / 1000) + 3600;

        const { v, r, s } = await getPermitSignature(
            userWallet1,
            votingAddress,
            100,
            deadline,
            tokenDistribution,
            nonce
        );

        // Cast votes on the poll with generated permit signature
        await voting.connect(userWallet1).castVotes(
            pollAddress,
            voteOptions,
            { deadline, v, r, s },
            { deadline, v, r, s }
        );

        // Log the actual values before assertions
        const voteCountOption0 = await poll.getVoteCount(0);
        const voteCountOption1 = await poll.getVoteCount(1);

        expect(voteCountOption0).to.equal(40);
        expect(voteCountOption1).to.equal(60);
    });
});
